Цель создания библиотеки - дать возможность программисту, знакомому с SQL и Java обеспечить взаимодействие первого со вторым, не ограничивая при этом возможности SQL - от простейшего подсчёта количества строк в таблице до сложных OLE запросов с CTE, группировками, вызовами функций, использованием массивов, перечислений, пользовательских типов и т. п.

Кроме того, библиотека должна рационально подходить к использованию ресурсов, давая возможность, например, исполнения SQL-запросов с очень большим количеством результирующих строк или колонок; давая возможность минимизировать нагрузку на сборщик мусора и т. п.

-----

Конвертация данных, передаваемых из БД и передаваемых в БД - разные процессы потому что JDBC интерфейс предоствляет информацию о типах колонок, которые передаются со стороны БД, а в обратную сторону тип параметров неизвестен. Т. е. если в первом случае библиотека может подобрать конвертор для данных (почти) самостоятельно, а в последнем случае приложение должно каким-то образом указать тип параметров для библиотеки.

-----

Можно попробовать связывать INTEGER с int, BIG INTEGER c long (т. е. с примитивами) с использованием JDBC-вызова isNullable(...). Но надо проверить насколько этот подход работоспособен для сложных вариантов запросов. В т. ч. для соотнесения результатов вызовов функций.

-----

Невозможно реализовать стандартный класс Spliterator и сделать на его базе стандартный же Stream поскольку 
во первых надо что-то делать с SQLException, а во вторых с этой конструкцией не получится вне зависимости от  
того, что происходит в потоке (например в случае использования forEach или в случае исключений в потоке) закрывать соединение - по крайней мере без try-catch блоков потому что вот: https://stackoverflow.com/questions/28813637/why-doesnt-java-close-stream-after-a-terminal-operation-is-issued 
Можно было бы попробовать обойти это через наследование от ReferencePipeLine, но там многие методы объявлены как final.
Так что своя реализация потоков была необходима.

-----

Меппинг со стороны БД:
1. Типы, отображающиеся на примитивы с боксингом (INTEGER, BIGINT, BOOLEAN, DOUBLE PRECISION и т. п.)
2. Типы, отображающиеся на объекты (TIMESTAMP, DATE, TEXT, NUMERIC, DECIMAL и т. п.) и тут же XML, JSON, 
3. Перечисления (ENUM)
4. Пользовательские типы. Их схема вычитывается 
5. Двоичные данные (то, что вычитывается как поток)
6. Массивы всего перечисленного - как одномерные, так и многомерные
7. Система порождает как потоки отдельных объектов, так и потоки POJO-классов.

Система также пытается интеллектуально подобрать возможные преобразования. Например преобразование массивов/коллекций попытается повторно провести преобрзование для внутренних членов массивов/коллекций. То есть если есть какой-то пользовательский тип и описано его соответствие некоему классу, то преобразователь массивов позволит также устанавливать соответствие между массивами значений этого пользовательского типа. Или же, например, задание специфического преобразования
BIG INTEGER -> Integer, будет автоматически означать возможность преобразования BIG INTEGER[] -> Integer[].

Относительно преобразований типов МАССИВОВ стоит заметить что у БД любой тип - это в терминах Java всегда объект, а не примитив - т. к. любой тип в БД допускает NULL-значения. Поэтому БД не возвращает примитивов. Библиотека может преобразовать объектный тип в примитивный, преднамеренно генерируя исключение конвертации если вдруг попадётся NULL. Однако следует учитывать, что это - дополнительное удобство пользователя библиотеки, сопряжённая с дополнительной работой библиотеки, которая необходима для преобразования массива одного типа в массив другого типа (в коллекциях примитивы хранить невозможно, поэтому речь только о массивах). Максимально эффективно будет всё же оставлять именно объектный тип, так как при этом библиотека фактически передаст пользователю сформированный JDBC-драйвером массив напрямую.

-----

Возможные варианты выставления соответствий результатов запроса с перечислениями зависят от конкретного типа перечисления и типа соотносимой колонки.

Если перечисление не реализует интерфейса Tagged, то, тип значение колонки будет приводиться к строковому и эти значения будут соотноситься с названиями констант перечисления. В обратном направлении (в качестве параметров запросов) будет использоваться строковой тип.

Если перечисление реализует интерфейс Tagged, то тип колонки должен будет соотноситься с типом, возвращаемым методом getTag(). В обратном направлении действуют те же правила, что и для прочих типов (передача в виде типа БД по умолчанию для конкретного типа getTag() либо его приведение к типу, указанному в аннотации SqlType

Допускается использование перечислений на стороне БД. Их обработка на текущий момент полноценно не реализована в драйвере PGJDBC, поэтому библиотека самостоятельно осуществляет разбор строки, в виде которой значения перечислений передаются со стороны БД клиенту (включая массивы). Для пользователя библиотеки использование перечислений на стороне БД примерно эквивалентно использованию строковых значений наименований констант перечислений пользователей. Необходимо отметить, что на стороне БД в составе названий констант перечислений допускается использовать пробелы и иные символы, недопустимые в названиях констант перечислений на стороне Java. Для такого рода перечислений со стороны БД необходимо реализовывать интерфейс Tagged, который будет предоставлять соответствующие константы для перечислений на стороне Java. 


-----

Вызовы, порождающие потоки различных типов (пользовательские классы либо встроенные классы) отличаются семантикой.

Если первым параметром указывается класс, то это вызов, SQL-запрос которого должен вернуть единственную колонку и
должен существовать конвертор, преобразующий тип этой колонки в указанный класс.

Скорее всего фактическое создание экземпляров указанного класса библиотека осуществлять не будет, а будет лишь транслировать этот тип напрямую из JDBC. Например в случае, если результат выполнения запроса - строка (TEXT или CHAR или VARCHAR), а в качестве фабрики предоставлен String.class, то библиотека получит единственный экземпляр String из фабрики, по нему отыщет преобразование TEXT -> String, которое просто возвращает значение колонки rs.getObject(1), приводимое к типу String, и именно таким образом будут порождаться элементы потока.

Для задействования ORM-функционала в библиотеку передаётся не класс, а фабрика классов. Это связано с тем, что не всегда можно отыскать для переданного класса конструктор по умолчанию или, даже найдя его, не всегда можно его использовать. Например для внутренних классов конструктор по умолчанию требует передачи одного параметра: ссылки на экземпляр внешнего класса. При создании экземпляра такого внутреннего класса пользователем этот параметр передаётся автоматически, а для библиотеки осуществлять подобное слишком сложно. Пользовательские классы могут также инициализироваться специфичным для приложения образом, изыматься из некоторого пула и т. п. Поэтому использование пользовательской фабрики классов для порождения объектов, которые в дальнейшем инициализируются библиотекой, более универсально и удобно.


-----
	
Из за стирания типов (Type erasure) библиотека не рассматривает классы, наследуемые от Collection и иные контейнерные типы в качестве целевых элементов так как не может корректно самостоятельно определить целевой тип и выбрать корректный конвертор. Вместо коллекций удобнее и эффективнее использовать массивы. Например вместо List<Integer>::new следует использовать Integer[]::new. Либо необходимо указать библилотеке на тип элемента коллекции через специальную аннотацию @SqlType

-----

Соответствие между полями POJO-объектов и колонками в БД выставляется реализацией интерфейса поиска соответствий. Различные реализации могут как поставляться вместе с библиотекой, так и предоставляться пользователем библиотеки.

-----

Главная проблема и боль библиотеки - позднее связывание SQL и Java-кода. То есть отсутствие этой связи на этапе компиляции. Но тут ничего не поделаешь - это происходит из за разной природы самих SQL и Java. Библиотека старается облегчить эту боль через логгирование фактически установленных связей в виде, подготовленному для автоматизированного поиска (с помощью утилиты grep и подобных). Практический смысл этого логгирования - в облегчении рефакторинга. Т. е. в облегчении поиска конкретных мест фактического использования элементов схемы БД (колонок таблиц, результатов выполнения функций и т. п.) с целью безопасного изменения их типа или удаления.

-----

В чём концептуальный недостаток CRUD-репозиториев (в частности Spring Data)? В том что они именно что CRUD. То есть предполагают вставку и обновление. Но предположим, что мы выбираем специфические данные из набора таблиц. Вставить или обновить их там уже невозможно. И у этих данных возможно есть какой-то хитрый составной ключ, а возможно его и нет вовсе. Но CRUD-репозиторий всё равно бессмысленно и в обязательном порядке требует описать ключи в т. ч. составные. Хотелось бы репозиторий только для чтения и с максимальной гибкостью. 

-----

Видится два варианта связывания колонок ака результатов выполнения запросов и полей объектов:

1. По именам полей и именам колонок (через некоторые возможные приведения одних к другим). Должно также выполняться преобразование типов данных.

Чтобы преодолеть неочевидность связывания запроса и класса можно попробовать помечать связываемые члены класса специальными аннотациями @Column. В случае несоответствия имени поля и названия колонки эту аннотацию использовать необходимо. Но при желании её также можно использовать и для явного указания программисту на то, что этот член класса инициализируется через ORM и исполнение некоторого запроса.

Однако не хотелось бы слишком далеко заходить в создании аннотаций, так как всё это влечёт за собой многословность и в некоторые случае ограничения на варианты запросов. Другими словами этот путь - путь пересоздания Hibernate-подобных ORM. Но как раз хотелось бы получить всё же нечто более простое, лаконичное и менее ограничивающее чем Hibernate.

2. Через конструкторы классов. Предполагается что колонки будут связываться с аргументами конструкторов. Во многом этот метод похож не предыдущий, однако имеет дополнительные сложности. В частности java-компилятор без специальных параметров не включает наименования методов в байт-код. Из за этого или надо будет или задавать параметр компиляции, чтобы связывать колонки с параметрами конструкторов по именам или указывать имена членов классов в аннотациях или ориентироваться на порядок колонок и параметров конструкторов. Все три подхода влекут свои сложности. В этом смысле подход (1) видится более простым, удобным и однозначным.
