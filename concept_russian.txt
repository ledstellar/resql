Цель создания библиотеки - дать возможность программисту, знакомому с SQL и Java обеспечить взаимодействие первого со вторым, не ограничивая при этом возможности SQL - от простейшего подсчёта количества строк в таблице до сложных OLE запросов с CTE, группировками, вызовами функций, использованием массивов, перечислений, пользовательских типов и т. п.

Кроме того, библиотека должна рационально подходить к использованию ресурсов, давая возможность, например, исполнения SQL-запросов с очень большим количеством результирующих строк или колонок; давая возможность минимизировать нагрузку на сборщик мусора и т. п.

-----

Команды для подготовки тестовой схемы:

CREATE ROLE resql LOGIN VALID UNTIL 'infinity' PASSWORD 'resql';
CREATE DATABASE resql WITH ENCODING='UTF8' OWNER=resql CONNECTION LIMIT=-1;
ALTER ROLE resql SET search_path = __resql_test;

-----

Конвертация данных, передаваемых из БД и передаваемых в БД - разные процессы потому что JDBC интерфейс предоствляет информацию о типах колонок, которые передаются со стороны БД, а в обратную сторону тип параметров неизвестен. Т. е. если в первом случае библиотека может подобрать конвертор для данных (почти) самостоятельно, а в последнем случае приложение должно каким-то образом указать тип параметров для библиотеки.

-----

Можно попробовать связывать INTEGER с int, BIG INTEGER c long (т. е. с примитивами) с использованием JDBC-вызова isNullable(...). Но надо проверить насколько этот подход работоспособен для сложных вариантов запросов. В т. ч. для соотнесения результатов вызовов функций.

-----

Невозможно реализовать стандартный класс Spliterator и сделать на его базе стандартный же Stream поскольку 
во первых надо что-то делать с SQLException, а во вторых с этой конструкцией не получится вне зависимости от  
того, что происходит в потоке (например в случае использования forEach или в случае исключений в потоке) закрывать соединение - по крайней мере без try-catch блоков потому что вот: https://stackoverflow.com/questions/28813637/why-doesnt-java-close-stream-after-a-terminal-operation-is-issued 
Можно было бы попробовать обойти это через наследование от ReferencePipeLine, но там многие методы объявлены как final.
Так что своя реализация потоков была необходима.

-----

Меппинг со стороны БД:
1. Типы, отображающиеся на примитивы с боксингом (INTEGER, BIGINT, BOOLEAN, DOUBLE PRECISION и т. п.)
2. Типы, отображающиеся на объекты (TIMESTAMP, DATE, TEXT, NUMERIC, DECIMAL и т. п.) и тут же XML, JSON, 
3. Перечисления (ENUM)
4. Пользовательские типы. Их схема вычитывается 
5. Двоичные данные (то, что вычитывается как поток)
6. Массивы всего перечисленного - как одномерные, так и многомерные
7. Система порождает как потоки отдельных объектов, так и потоки POJO-классов.

Система также пытается интеллектуально подобрать возможные преобразования. Например преобразование массивов/коллекций попытается повторно провести преобрзование для внутренних членов массивов/коллекций. То есть если есть какой-то пользовательский тип и описано его соответствие некоему классу, то преобразователь массивов позволит также устанавливать соответствие между массивами значений этого пользовательского типа. Или же, например, задание специфического преобразования BIG INTEGER -> Integer, будет автоматически означать возможность преобразования BIG INTEGER[] -> Integer[].

В ЦЕЛОМ схема ORM предполагается следующей:

НА ПЕРВОМ ЭТАПЕ соотносятся поля на стороне БД (результата запроса) и java исключительно по наименованиям. При этом возможны разнообразные преобразования - запись с подчёркиванием в горбатую, перестановка id_ в конец и т. п. Главное чтобы это соотнесение было однозначным.

НА ВТОРОМ ЭТАПЕ происходит подбор преобразований и функций передачи данных для полей, которым найдено соответствие. Поскольку данных по типам может не хватать как на одной так и на другой стороне система может гибко адаптироваться к конкретной ситуации.

Например в случае использования контейнеров на стороне явы из за механизма стирания типов тип элемента контейнера почти всегда невозможно определить (кроме случаев, когда предполагается присваивание непосредственно в свойство класса). В таких случаях (когда тип элемента контейнера не представляется возможным определить) механизм подбора преобразований может ориентироваться на метаданные соответствующей колонки результата-запроса либо на тип элемента контейнера, заданный пользователем через аннотацию. Если же мы транслируем данные в обратном направлении (формируем фактические значения параметров), то метаданные колонок уже недоступны и система вынуждена будет ориентироваться на преобразование по умолчанию во всех случаях, кроме тех, когда пользователь опять же представил аннотации с конкретным типом параметра на стороне БД.

С другой стороны если в колонке возвращается массив значений некоторого типа, то определение размерности этого массива происходит только в момент получения фактического значения этой колонки. Но если в качестве фактического значения возвращён NULL, то размерность массива со стороны JDBC невозможно определить вообще никак. В этом случае система подбора преобразований либо может ориентироваться на размерность массива, который предоставлен пользователем со стороны джава. А если и это невозможно (например предполагается возвращать значения из одной колонки в виде потока, а пользователь предоставил поставщика контейнеров в качестве целевого типа преобразования), то система будет вынуждена либо ориентироваться на дополнительные подсказки пользователя через аннотации либо предоставлять некоторое преобразование по умолчанию. В качестве преобразования по умолчанию видится разумным преобразование к одномерному массиву.

Относительно преобразований типов МАССИВОВ отдельно стоит заметить что у БД любой тип - это в терминах Java всегда объект, а не примитив - т. к. любой тип в БД допускает NULL-значения. Поэтому БД не возвращает примитивов. Библиотека может преобразовать объектный тип в примитивный, преднамеренно генерируя исключение конвертации если вдруг попадётся NULL. Однако следует учитывать, что это - дополнительное удобство пользователя библиотеки, сопряжённая с дополнительной работой библиотеки, которая необходима для преобразования массива одного типа в массив другого типа (в коллекциях примитивы хранить невозможно, поэтому речь только о массивах). Максимально эффективно будет всё же оставлять именно объектный тип, так как при этом библиотека фактически передаст пользователю сформированный JDBC-драйвером массив напрямую.

-----

Возможные варианты выставления соответствий результатов запроса с перечислениями зависят от конкретного типа перечисления и типа соотносимой колонки.

Если перечисление не реализует интерфейса Tagged, то, тип значение колонки будет приводиться к строковому и эти значения будут соотноситься с названиями констант перечисления. В обратном направлении (в качестве параметров запросов) будет использоваться строковой тип.

Если перечисление реализует интерфейс Tagged, то тип колонки должен будет соотноситься с типом, возвращаемым методом getTag(). В обратном направлении действуют те же правила, что и для прочих типов (передача в виде типа БД по умолчанию для конкретного типа getTag() либо его приведение к типу, указанному в аннотации SqlType

Допускается использование перечислений на стороне БД. Их обработка на текущий момент полноценно не реализована в драйвере PGJDBC, поэтому библиотека самостоятельно осуществляет разбор строки, в виде которой значения перечислений передаются со стороны БД клиенту (включая массивы). Для пользователя библиотеки использование перечислений на стороне БД примерно эквивалентно использованию строковых значений наименований констант перечислений пользователей. Необходимо отметить, что на стороне БД в составе названий констант перечислений допускается использовать пробелы и иные символы, недопустимые в названиях констант перечислений на стороне Java. Для такого рода перечислений со стороны БД необходимо реализовывать интерфейс Tagged, который будет предоставлять соответствующие константы для перечислений на стороне Java. 


ENUM -> encoded string (not decoded with PgJDBC driver) -> String array value parser -> Converter -> ENUM.name(), Tagged<String>.getTag()
Integer, Long, SmallInt -> Converter -> ENUM.ordinal()
      SomeType -> Converter -> Tagged<ConvertedType>.getTag()


-----

Вызовы, порождающие потоки различных типов (пользовательские классы либо встроенные классы) отличаются семантикой.

Если первым параметром указывается класс, то это вызов, SQL-запрос которого должен вернуть единственную колонку и
должен существовать конвертор, преобразующий тип этой колонки в указанный класс.

Скорее всего фактическое создание экземпляров указанного класса библиотека осуществлять не будет, а будет лишь транслировать этот тип напрямую из JDBC. Например в случае, если результат выполнения запроса - строка (TEXT или CHAR или VARCHAR), а в качестве фабрики предоставлен String.class, то библиотека получит единственный экземпляр String из фабрики, по нему отыщет преобразование TEXT -> String, которое просто возвращает значение колонки rs.getObject(1), приводимое к типу String, и именно таким образом будут порождаться элементы потока.

Для задействования ORM-функционала в библиотеку передаётся не класс, а фабрика классов. Это связано с тем, что не всегда можно отыскать для переданного класса конструктор по умолчанию или, даже найдя его, не всегда можно его использовать. Например для внутренних классов конструктор по умолчанию требует передачи одного параметра: ссылки на экземпляр внешнего класса. При создании экземпляра такого внутреннего класса пользователем этот параметр передаётся автоматически, а для библиотеки осуществлять подобное слишком сложно. Пользовательские классы могут также инициализироваться специфичным для приложения образом, изыматься из некоторого пула и т. п. Поэтому использование пользовательской фабрики классов для порождения объектов, которые в дальнейшем инициализируются библиотекой, более универсально и удобно.


-----

Если говорить об ORM, то преобразования типов в обоих направлениях (из БД в Java и наоборот) привязаны к интерфейсам JDBC. Поэтому "нанизывание" преобразований всегда начинается с типа JDBC и может проходить через преобразования через разные структуры данных java. Для параметров запросов ситуация иная, так как финальный тип данных параметров запросов через интерфейсы JDBC выяснить невозможно.

Если рассматривать преобразование данных, то можно разделить это на следующие направления:

1. Из БД в Java (или значения потоков примитивов).

В этом направлении у нас всегда есть метаданные от БД, по которым можно грубо выяснить переданный тип, а в сложных моментах (перечисления, пользовательские типы и т. п.) можно узнать наименование переданного типа на стороне БД. При этом у любой колонки в любом случае есть наименование. Поэтому библиотека сначала определяет соответствие колонок и полей классов (при использовании механизмов ORM), а затем пытается подобрать преобразование из имеющегося типа колонки в имеющийся тип класса (или конкретный примитив - в случае с потоками примитивов). В некоторых особо сложных случаях (пользовательский тип) библиотека может запросить дополнительные данные от БД параллельным запросом. Например информацию о пользовательском типе.

2. Из Java в БД. 

2.1. UPDATE-INSERT-UPSERT-запросы.

Во избежание усложнения библиотека работает только с отношениями один класс-одна таблица. Соотношения между объектами и записями таблиц в БД соответственно решаются на прикладном уровне.

Для определения соответствия БД делает однократный "пристрелочный" запрос SELECT * FROM tableName LIMIT 0. Имея метаданные этого запроса вопрос соответствия между типами на стороне БД и на стороне Java решается способом, похожим на тот, что используется для преобразований из БД в Java (разве что проверки при "расширительных" преобразованиях могут быть иными).

2.2. Параметры запросов (то, что подставляется вместо вопросиков сюда: SELECT * FROM tableName WHERE id = ? AND val IN (?))

Это самый сложный случай. У библитеки нет данных про "тип назначения" и нет способов его получить. Поэтому библиотека ориентируется только на тип, переданный пользователем в фактических параметрах. То есть int и Integer преобразуются в INTEGER, long и Long - в BIG INTEGER и т. п.

Возможны (а в некоторых, наиболее сложных случаях - например для случаев параметров-коллекций) необходимы подсказки со стороны пользователя, который уведомляет библиотеку о фактическом типе параметра. В этом случае библиотека задействует преобразование из этого типа в тип БД.

-----

Транзакционно можно выполнять запросы последовательно (специфическая реализация транзакции)
	pipe.transactionalUpdate((pipe) -> pipe
		.execute("CREATE TABLE t(id INTEGER, txt TEXT)")
		.execute("INSERT INTO t(id, txt) VALUES (1, 'VAL 1'), (2, 'VAL 2'), (3, 'VAL 3')")
		.execute("SELECT COUNT(*) INTO tc SELECT COUNT(*) FROM t")
	);

-----

Соответствие между полями POJO-объектов и колонками в БД выставляется реализацией интерфейса поиска соответствий. Различные реализации могут как поставляться вместе с библиотекой, так и предоставляться пользователем библиотеки.

-----

Главная проблема и боль библиотеки - позднее связывание SQL и Java-кода. То есть отсутствие этой связи на этапе компиляции. Но тут ничего не поделаешь - это происходит из за разной природы самих SQL и Java. Библиотека старается облегчить эту боль через логгирование фактически установленных связей в виде, подготовленному для автоматизированного поиска (с помощью утилиты grep и подобных). Практический смысл этого логгирования - в облегчении рефакторинга. Т. е. в облегчении поиска конкретных мест фактического использования элементов схемы БД (колонок таблиц, результатов выполнения функций и т. п.) с целью безопасного изменения их типа или удаления.

-----

В чём концептуальный недостаток CRUD-репозиториев (в частности Spring Data)? В том что они именно что CRUD. То есть предполагают вставку и обновление. Но предположим, что мы выбираем специфические данные из набора таблиц. Вставить или обновить их там уже невозможно. И у этих данных возможно есть какой-то хитрый составной ключ, а возможно его и нет вовсе. Но CRUD-репозиторий всё равно бессмысленно и в обязательном порядке требует описать ключи в т. ч. составные. Хотелось бы репозиторий только для чтения и с максимальной гибкостью. 

-----

Видится два варианта связывания колонок ака результатов выполнения запросов и полей объектов:

1. По именам полей и именам колонок (через некоторые возможные приведения одних к другим). Должно также выполняться преобразование типов данных.

Чтобы преодолеть неочевидность связывания запроса и класса можно попробовать помечать связываемые члены класса специальными аннотациями @Column. В случае несоответствия имени поля и названия колонки эту аннотацию использовать необходимо. Но при желании её также можно использовать и для явного указания программисту на то, что этот член класса инициализируется через ORM и исполнение некоторого запроса.

Однако не хотелось бы слишком далеко заходить в создании аннотаций, так как всё это влечёт за собой многословность и в некоторые случае ограничения на варианты запросов. Другими словами этот путь - путь пересоздания Hibernate-подобных ORM. Но как раз хотелось бы получить всё же нечто более простое, лаконичное и менее ограничивающее чем Hibernate.

2. Через конструкторы классов. Предполагается что колонки будут связываться с аргументами конструкторов. Во многом этот метод похож не предыдущий, однако имеет дополнительные сложности. В частности java-компилятор без специальных параметров не включает наименования методов в байт-код. Из за этого или надо будет или задавать параметр компиляции, чтобы связывать колонки с параметрами конструкторов по именам или указывать имена членов классов в аннотациях или ориентироваться на порядок колонок и параметров конструкторов. Все три подхода влекут свои сложности. В этом смысле подход (1) видится более простым, удобным и однозначным.
